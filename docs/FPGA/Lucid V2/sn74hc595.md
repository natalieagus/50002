---
layout: default
permalink: /fpga/sn74hc595
title: SN74HC595 
description: Tips on how to use instructor's drivers 
parent: Lucid V2
grand_parent: 1D&2D Project (FPGA)
nav_order:  7
---


* TOC
{:toc}

**50.002 Computation Structures**
<br>
Information Systems Technology and Design
<br>
Singapore University of Technology and Design

## **Driving SN74HC595 with an FPGA**  

### Driver Code 

You can download the driver code from [here](https://github.com/natalieagus/sn74hc595-v2/blob/main/source/sn74hc595_driver.luc).

The entire repository with [demo code](https://github.com/natalieagus/sn74hc595-v2.git) can be found here.


## How SN74HC595 Works

The SN74HC595 is an **8-bit serial-in, parallel-out shift register** with a second **8-bit storage (output) register** behind it. You **shift bits in serially**, then **latch** them so the outputs update all at once. 

It has **separate clocks** for shifting vs latching, and the outputs can be **3-stated** (disconnected) using `OE`. 

You can read [this tutorial](https://docs.sunfounder.com/projects/beginners-lab-kit/en/latest/24_flowing_light.html) to understand more on how to connect the pins. It has many pinouts, so you still need to do lots of hardware work but the connection to the FPGA is minimal. This is particularly good if you have tons of LEDs to connect, and don't mind raw soldering work but run out of pins from the FPGA.

<img src="{{ site.baseurl }}//docs/FPGA/Lucid%20V2/images/sn74hc595/2026-01-06-11-23-58.png"  class="center_seventy no-invert"/>

> Image taken from this [video](https://www.youtube.com/watch?v=GpubV71Llh4).

### Pins 

<img src="{{ site.baseurl }}//docs/FPGA/Lucid%20V2/images/sn74hc595/2026-01-06-11-26-42.png"  class="center_seventy"/>


Here are the pin names and the corresponding label in the code:
* `SER` (labeled `ds`): serial data input. 
* `SRCLK` (labeled `shcp`): **shift clock**; on each **rising edge**, the bit on `SER` enters the first stage and everything shifts along.  
* `RCLK` (labeled `stcp`): **latch clock**; on a **rising edge**, the current shift-register contents copy into the storage register (this is what updates `QA..QH`). 
* `OE` (labeled `oe`): **output enable**; `OE=1` disables outputs (high-Z), `OE=0` enables outputs. 
* `SRCLR` (labeled `mr`, active-low): **direct clear of the shift register** when low (independent of clocks).  
* `QH'`: serial output used for **daisy-chaining** to the next chip’s `SER`. 
* `QB-QH`: parallel output to each LED. You need a resistor for each connection.

### The basic “send pattern” sequence

Here are the general steps on how to pump the data in:
1. **(Optional) Disable outputs** during shifting: set `OE=1` (outputs high-Z). 
2. For each bit (total `CHAIN * 8` bits):
   * Put next bit on `SER` (`ds`)
   * Pulse `SRCLK` (`shcp`) **low→high** to shift it in 
3. Pulse `RCLK` (`stcp`) **low→high** once to **latch** all 8 (or 16, 24, …) bits to `QA..QH`. 
4. **Enable outputs**: set `OE=0` to drive the pins. 

### Daisy-chaining 

* With `CHAIN = N`, you’re effectively building a **8N-bit shift chain**: bits you clock in first will “move down the line” and eventually end up in the farthest chip after enough `SRCLK` pulses.
* `QH'` is exactly there so the first chip can feed the second chip, and so on. 

### How the driver FSM maps to the datasheet behavior

* `IDLE`: wait for `new`, capture `data` into an internal register.
* `LOAD`: align so you don’t miss the first bit relative to your generated shift clock.
* `TRANSFER`: drive `ds`, pulse `shcp` for **`CHAIN*8` rising edges** (shift operation).
* `LATCH`: pulse `stcp` once (copy shift to storage, updating outputs). 
* `RESET`: pull `mr` low briefly to clear the **shift register**. 

## Debug Notes

**Clearing (`SRCLR` / `mr`) clears the shift register, not the outputs immediately.** Outputs change only when you latch with `RCLK`.  

If you ever tie `SRCLK` and `RCLK` together, the datasheet notes the shift register ends up **one clock ahead** of the storage register, which is why most designs keep them separate. 
